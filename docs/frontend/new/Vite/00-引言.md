中文官网：https://cn.vitejs.dev/



[【前端构建天花板】这可能是全B站最硬核的Vite7教程！深度剖析+实战工作流，彻底告别龟速打包！](https://www.bilibili.com/video/BV11mHhzTEjB/?spm_id_from=333.337.search-card.all.click&vd_source=b850b3a29a70c8eb888ce7dff776a5d1)



Vite7基础

Vite打包构建原理

Vite体系架构微内核思想

Vite7插件开发实战

Vite7源码解读

手写Vite7

# Vite 7 极速进阶与原理深度剖析

## 问题1：Vite 和 Webpack有什么区别？

**详细说说Vite7工程化细节，常见配置和优化手段**

Webpack缺点：

1. 增量启动慢
2. 性能表现差一些
3. 配置复杂

Vite优势：

1. 开发环境启动快
2. 性能好
3. 配置简单，开箱即用

## 问题2：有没有了解过微内核设计？

**Vite7的插件化设计思想怎样完成个性化打包构建需求？**

**软件架构思想：微内核（Microkernel）设计**

在深入Vite插件系统之前，有必要先理解一种经典的软件架构模式——**微内核架构。**

微内核架构的核心思想是将系统功能划分为两个主要部分：一个最小化的**核心系统（Kernel）和一系列可插拔的插件或服务（Plugins/Services）。**

- **核心系统（Kernel）插件底座：**只负责提供系统运行所必需的最基础、最通用的功能。例如，操作系统的内核可能只负责进程调度、内存管理和进程间通信（IPC）。它的设计目标是**稳定、精简、高效。**
- **插件/服务（Plugins）插件协议**：将所有非核心的功能，如文件系统、设备驱动、用户界面等，都作为独立的插件或服务来实现。这些插件运行在核心系统之上，通过核心系统提供的标准接口运行通知和协作。

这种架构的优势显而易见：

1. **高可扩展性（Extensibility）：**添加新功能只需开发一个新的插件，而无需修改核心系统。
2. **灵活性（Flexibility）：**用户可以根据自己的需求，自由组合和加载所需的功能插件。
3. **关注点分离（Separation of Concerns）：**核心系统开发者可以专注于底层稳定性，而功能开发者可以专注于业务逻辑，两者解耦。



**Vite作为微内核架构的实现**

Vite的整体设计，是微内核架构在前端构建工具领域的绝佳实践。

- **Vite的“内核”：**
  - 一个基于原生ESM的开发服务器：提供按需编译和模块服务的基本能力。
  - **依赖预构建与模块图解析：**负责处理第三方依赖和维护模块间的依赖关系。
  - **一个高度可扩展的插件接口：**这是其架构的灵魂，定义了外部功能如何与Vite的生命周期进行交互。
- Vite的“插件/服务”：
- Vite将几乎所有上层功能都通过插件来实现。我们日常使用的 @vitejs/plugin-vue 、 @vitejs/plugin-react 等，都是典型的插件。甚至 Vite 自身的许多内置功能（如CSS处理、JSON加载等）也是通过内部插件实现的。

这种设计使得Vite的核心极其轻量，同时又赋予了它无限的扩展能力。开发者可以像搭积木一样，通过组合不同的插件来打造完全符合自身项目需求的、个性化的打包构建工作流。

## Vite的生命周期钩子

### 1 钩子分类

#### 1. **按来源分类**（最清晰的分类）

- **Rollup 通用钩子**：继承自 Rollup，在开发和生产构建中都可用
- **Vite 特有钩子**：Vite 自己扩展的，主要服务于开发服务器

#### 2. **Rollup 钩子按执行阶段细分**

对于 Rollup 通用钩子，可以进一步按它们在构建流程中的位置分为：

##### 🏗️ **构建阶段钩子**（Module Graph Construction）

处理模块加载、解析、转换的钩子

| 钩子           | 作用              |
| :------------- | :---------------- |
| `options`      | 读取/替换配置选项 |
| `buildStart`   | 构建开始          |
| `resolveId`    | 解析模块路径      |
| `load`         | 加载模块内容      |
| `transform`    | 转换模块内容      |
| `moduleParsed` | 模块解析完成      |

##### 📦 **输出生成阶段钩子**（Output Generation）

处理最终 bundle 生成和写入的钩子

| 钩子             | 作用              |
| :--------------- | :---------------- |
| `buildEnd`       | 所有模块构建完成  |
| `outputOptions`  | 读取/替换输出配置 |
| `renderStart`    | 开始生成输出      |
| `renderChunk`    | 处理单个 chunk    |
| `generateBundle` | 操作最终 bundle   |
| `writeBundle`    | 文件写入完成      |
| `closeBundle`    | 清理资源          |

#### 3. **Vite 特有钩子按用途细分**

##### 🔧 **配置相关钩子**

| 钩子             | 作用       |
| :--------------- | :--------- |
| `config`         | 解析配置前 |
| `configResolved` | 配置解析后 |

##### 🖥️ **开发服务器钩子**

| 钩子                 | 作用           |
| :------------------- | :------------- |
| `configureServer`    | 配置开发服务器 |
| `transformIndexHtml` | 处理 HTML 文件 |
| `handleHotUpdate`    | 处理 HMR 更新  |

### 2 可视化理解

```tex
Vite 生命周期钩子
├── 🔄 Rollup 通用钩子
│   ├── 🏗️ 构建阶段
│   │   ├── options
│   │   ├── buildStart
│   │   ├── resolveId → load → transform → moduleParsed
│   │   └── (对每个模块循环)
│   └── 📦 输出生成阶段
│       ├── buildEnd
│       ├── outputOptions
│       ├── renderStart
│       ├── renderChunk
│       ├── generateBundle
│       ├── writeBundle
│       └── closeBundle
│
└── ⚡ Vite 特有钩子
    ├── 🔧 配置相关
    │   ├── config
    │   └── configResolved
    └── 🖥️ 开发服务器
        ├── configureServer
        ├── transformIndexHtml
        └── handleHotUpdate
```

### 3 Vite 的运行模式与执行的钩子关系

| 运行模式     | 命令                 | 钩子执行特点                                                 |
| :----------- | :------------------- | :----------------------------------------------------------- |
| **开发模式** | `vite` 或 `vite dev` | 主要执行 Vite 特有钩子 + Rollup 的**构建阶段钩子**，不执行**输出生成阶段钩子** |
| **生产构建** | `vite build`         | 执行 Rollup 的**所有钩子**（构建阶段 + 输出生成阶段）        |

| 钩子类型                                                     | 开发模式 (`vite dev`) | 生产构建 (`vite build`) |
| :----------------------------------------------------------- | :-------------------- | :---------------------- |
| **Vite 配置钩子**                                            | ✅                     | ✅                       |
| `config`, `configResolved`                                   | ✅                     | ✅                       |
| **Vite 开发服务器钩子**                                      | ✅                     | ❌                       |
| `configureServer`, `handleHotUpdate`                         | ✅                     | ❌                       |
| **Vite HTML 处理钩子**                                       | ✅                     | ✅                       |
| `transformIndexHtml`                                         | ✅                     | ✅                       |
| **Rollup 构建阶段钩子**                                      | ✅                     | ✅                       |
| `options`,`buildStart`,`resolveId`, `load`,`transform`, `moduleParsed` | ✅                     | ✅                       |
| **Rollup 输出生成钩子**                                      | ❌                     | ✅                       |
| `buildEnd`,`outputOptions`,`renderStart`,`renderChunk`<br/>`generateBundle`, `writeBundle`,`closeBundle`等 | ❌                     | ✅                       |

### 4 完整执行顺序总结（以 `vite build` 为例）

#### 1 开发模式下执行顺序

0. **构建之前**

- <span style="color:#00CED1;font-weight:bold;">`config`（解析配置前）</span>
- <span style="color:#00CED1;font-weight:bold;">`configResolved`（配置解析后）</span>

1. **构建开始**
   - <span style="color:#69953d;font-weight:bold;">`options` (替换配置)</span>
   - <span style="color:#00CED1;font-weight:bold;">`configureServer`（配置开发服务器）</span>
   - <span style="color:#69953d;font-weight:bold;">`buildStart` (构建开始)</span>

2. **模块加载与转换（对图中的每个模块循环）**

   - <span style="color:#00CED1;font-weight:bold;">`transformIndexHtml`（转换HTML）</span>

   - <span style="color:#69953d;font-weight:bold;">`resolveId` (解析路径)</span> <span style="color:red;font-weight:bold;">（首次，没有`node_modules/.vite`缓存情况下，才执行）</span>
   - <span style="color:#69953d;font-weight:bold;">`load` (加载源码)</span>
   - <span style="color:#69953d;font-weight:bold;">`transform` (转换源码)</span>

#### 2 生产模式下执行顺序

一个更直观的顺序流程如下：

0. **构建之前**
   - <span style="color:#00CED1;font-weight:bold;">`config`（解析配置前）</span>
   - <span style="color:#00CED1;font-weight:bold;">`configResolved`（配置解析后）</span>

1. **构建开始**
   - <span style="color:#69953d;font-weight:bold;">`options` (替换配置)</span>
   - <span style="color:#69953d;font-weight:bold;">`buildStart` (构建开始)</span>
2. **模块加载与转换（对图中的每个模块循环）**
   - <span style="color:#69953d;font-weight:bold;">`resolveId` (解析路径)</span>
   - <span style="color:#69953d;font-weight:bold;">`load` (加载源码)</span>
   - <span style="color:#69953d;font-weight:bold;">`transform` (转换源码)</span>
   - <span style="color:#69953d;font-weight:bold;">`moduleParsed` (模块解析完毕)</span>
3. **构建结束，准备输出**
   - <span style="color:#69953d;font-weight:bold;">`buildEnd` (所有模块构建完毕)</span>
4. **输出生成**
   - <span style="color:#a18b2f;font-weight:bold;">`outputOptions` (替换输出配置)</span>
   - <span style="color:#a18b2f;font-weight:bold;">`renderStart` (开始渲染输出)</span>
   - `banner`/`footer`/... (添加包装代码)
   - <span style="color:#a18b2f;font-weight:bold;">`renderChunk` (转换单个 chunk)</span>
   - <span style="color:#a18b2f;font-weight:bold;">`generateBundle` (操作最终 bundle)</span>
   - <span style="color:#00CED1;font-weight:bold;">`transformIndexHtml`（转换HTML）</span>
   - <span style="color:#a18b2f;font-weight:bold;">`writeBundle` (文件已写入磁盘)</span>
   - <span style="color:#a18b2f;font-weight:bold;">`closeBundle` (清理资源)</span>

### 5 Vite插件执行顺序(enforce: pre)影响与分析

<span style="color:#9400D3;font-weight:bold;">现象：当执行 `pnpm build`时发现，若你的插件配置了`enforce: 'pre'`，`resolveId`钩子会被执行，否则，不会被执行。</span>

**Vite 插件有三个执行阶段：**

- `pre` - 最先执行
- `normal` - 默认顺序（没有 enforce 时）
- `post` - 最后执行

**Vite 内置插件的影响**

Vite 有很多内置插件，比如：

- `vite:resolve` - 负责模块解析
- `vite:esbuild` - 负责代码转换
- `vite:html` - 处理 HTML 文件

**没有 `enforce: 'pre'` 时**：

```js
// 插件执行顺序可能是：
vite:resolve (内置) → 你的插件 → vite:esbuild → ...
```

**有 `enforce: 'pre'` 时**：

```js
// 插件执行顺序：
你的插件 (pre) → vite:resolve (内置) → vite:esbuild → ...
```

- 你的插件先执行，`resolveId` 有机会处理模块解析



## 问题3：Vite的插件化设计思想怎样完成个性化打包构建需求

一个结构化的回答应包含以下几点：

1. **架构层面：**Vite采用了**微内核设计**。它的核心非常轻量，仅包含一个ESM开发服务器和一套插件加载机制。所有高层功能，如框架支持、CSS预处理、特定文件加载等，都由独立的插件实现。
2. **接口层面：**Vite提供了**一套兼容Rollup的、统一的插件接口**。这套接口通过暴露一系列**生命周期钩子（Hooks）**，允许开发者在构建过程的各个关键节点（如配置解析、模块加载、代码转换、HTML生成等）注入自定义逻辑。
3. **实践层面：**开发者可以编写一个插件，通过选择合适的钩子来完成特定任务。例如，使用`transform`钩子可以支持一种新的语言或文件格式；使用`configureServer`钩子可以在开发时添加自定义的服务器中间件；使用`transformIndexHtml`则可以动态修改主页面的内容。
4. **结论：**这种设计思想将“扩展能力”作为框架的一等公民，而非附属品。它将复杂的构建流程解耦为一系列简单、独立的插件，开发者可以按需组合它们，从而**灵活、低成本地实现任何高度个性化的打包构建需求**的同时保证了核心系统的稳定与简洁。

