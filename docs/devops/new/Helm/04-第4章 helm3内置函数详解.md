# 第4章 helm3内置函数详解

## 1 常用的helm3内置函数

- quote 或 squote 函数
- upper 和 lower 函数
- repeat 函数
- default 函数
- lookup 函数



## 2 函数的使用格式

格式1：函数名 arg1 arg2 …，然而在实际的使用中，我们更偏向于使用管道符|来将参数传递给函数。

格式2：arg1|函数名		这样使用可以使结构看起来更加直观，并且可以方便使用多个函数对数据进行链式处理。



## 3 环境准备
### 3.1 环境准备 K8S集群

```bash
$ kubectl get node
NAME    STATUS   ROLES                  AGE   VERSION
emon    Ready    control-plane,master   12d   v1.23.17
emon2   Ready    <none>                 11d   v1.23.17
emon3   Ready    <none>                 11d   v1.23.17
```

### 3.2 创建一个chart包

```bash
$ helm create mychart
$ cd ~/mychart/templates
$ rm -rf *
```

### 3.3 特殊说明

```bash
{{- }} # 表示向左删除空白，包括删除空格和换行，不加可能会增加一个换行，前面加横线是为了去掉该行的空格，如果不加，该行渲染时会形成空格。
{{ -}} # 表示向右删除空白，并且会删除换行，一般慎用（因为删除换行时候，打印内容就乱了，还可能语法报错）
```



## 4 各内置函数使用的演示

### 4.1 helm3的内置函数简单介绍

#### 4.1.1 quote 和 squote 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ quote .Values.name }} # 调用的变量值添加一个双引号（quote）
  value2: {{ .Values.name | squote }} # 调用的变量值添加一个单引号（squote）
EOF

# 配置变量
$ echo name: test > ~/mychart/values.yaml

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.1.2 upper 和 lower 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ .Values.name1 | upper | quote }} # 调用的变量值，转成大写（upper）且添加一个双引号（quote）
  value2: {{ .Values.name2 | lower | squote }} # 调用的变量值，转成小写(lower)且添加一个单引号（squote）
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
name1: test 
name2: TEST
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.1.3 repeat 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ .Values.name1 | repeat 3 | quote }} # 调用的变量值，输出重复 3 次且添加一个双引号（quote）
  value2: {{ .Values.name2 | repeat 2 | squote }} # 调用的变量值，输出重复 2 此且添加一个单引号（squote）
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
name1: test 
name2: TEST
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.1.4 default 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ .Values.location | default "beijing" | quote }} # 调用的变量值，不存在时使用定义的默认值且添加一个双引号（quote）
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```



#### 4.1.5 lookup 函数

使用lookup函数用于在当前的K8S集群中获取一些资源的信息，功能有些类似于`kubectl get xxx`

函数的格式如下：

`lookup "apiVersion" "kind" "namespace" "name"`其中`"namespace"`和`"name"`都是可选的，或可以指定为空字符串`“”`，函数执行完成后会返回特定的资源。

常用格式和`kubectl`命令相互对应关系：

| kubectl命令                            | lookup函数                                 |
| -------------------------------------- | ------------------------------------------ |
| `kubectl get pod mypod -n mynamespace` | `lookup "v1" "Pod" "mynamespace" "mypod"`  |
| `kubectl get pods -n mynamespace`      | `lookup "v1" "Pod" "mynamespace" ""`       |
| `kubectl get pods --all-namespaces`    | `lookup "v1" "Pod" "" ""`                  |
| `kubectl get namespace mynamespace`    | `lookup "v1" "Namespace" "" "mynamespace"` |
| `kubectl get namespaces`               | `lookup '"v1" "Namespace" "" ""'`          |

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ lookup "v1" "Namespace" "" "" | quote }} # 相当于：kubectl get namespaces 并对结果加上一个双引号（quote）
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 需要安装后才能查看到相应信息
$ helm install myconfigmap ~/mychart
# 安装成功后，用 helm get manifest release名 命令可以查看已经发布到K8S中的release信息
$ helm get manifest myconfigmap
```

### 4.2 helm3的逻辑和流控制函数

#### 4.2.1 常见的逻辑和流控制函数

| 函数     | 作用                                                         |
| -------- | ------------------------------------------------------------ |
| eq       | 用于判断两个参数是否相等，如果等于则为true，不等于则为false  |
| ne       | 用于判断两个参数是否不相等，如果不等于则为true，等于则为false |
| lt       | 用于判断第一个参数是否小于第二个参数，如果成立则为true，如果不成立则为false |
| le       | 用于判断第一个参数是否小于等于第二个参数，如果小于等于则为true，否则为false |
| gt       | 用于判断第一个参数是否大于第二个参数，如果成立则为true，如果不成立则为false |
| ge       | 用于判断第一个参数是否大于等于第二个参数，如果成立则为true，如果不成立则为false |
| and      | 返回两个参数的逻辑与结果（布尔值），也就是说如果两个参数为真，则结果为true。否则，返回false |
| or       | 判断两个参数的逻辑或的关系，两个参数中有一个为真，则为真。返回第一个不为空的参数或者是返回后一个参数 |
| not      | 用于对参数的布尔值取反，如果参数是正常参数（非空），正常为true，取反后就位false。<br />参数是空的，正常是false，取反后是true。 |
| default  | 用来设置一个默认值，在参数的值为空的情况下，则会使用默认值。 |
| empty    | 用于判断给定值是否为空，如果为空则返回true                   |
| coalesce | 用于扫描一个给定的列表，并返回第一个非空的值。               |
| ternary  | 接受两个参数和一个test值，如果test的布尔值为true，则返回第一个参数的值，如果test的布尔值为false，则返回<br />第二个参数的值。 |

#### 4.2.2 eq 和 ne函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ eq 2 2 }}
  value2: {{ eq 2 1 }}
  value2: {{ ne 2 1 }}
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.3 lt函数、le函数、gt函数、ge函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ lt 1 2 }}
  value2: {{ le 2 1 }}
  value2: {{ gt 1 2 }}
  value2: {{ ge 2 2 }}
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.4 and函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ and .Values.name1 .Values.name2 | quote }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
name1: true
name2: false
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.5 or函数

什么是空类型？主要有以下几种：

- 整型：0

- 字符串：“”

- 列表：[]

- 字典：{}

- 布尔：false

- 以及所有的nil（或者null）

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  value1: {{ or 1 "" 2 | quote }}
  value2: {{ or 1 2 "" | quote }}
  value3: {{ or "" 2 3 | quote }}
  value4: {{ or "" "" 3 | quote }}
  value5: {{ or "" "" "" | quote }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.6 not函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  type1: {{ not 2 | quote }}
  type2: {{ not "" | quote }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.7 default函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  values: {{ .Values.address | default "bj" | quote }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
name1: test
name2: TEST
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.8 empty函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  type1: {{ 0 | empty }}
  type2: {{ 1 | empty }}
  type3: {{ "" | empty }}
  type4: {{ false | empty }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.9 coalesce函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  type1: {{ coalesce 0 1 2 }}
  type2: {{ coalesce "" false "Test" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.2.10 ternary函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  type1: {{ ternary "First" "Second" true }}
  type2: {{ ternary "First" "Second" false }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.3 helm3的字符串函数

#### 4.3.1 常用的helm3字符串函数

| 函数                                                   |
| ------------------------------------------------------ |
| print 和 println                                       |
| printf                                                 |
| trim 、 trimAll 、 trimPrefix 、 trimSuffix            |
| lower 、 upper 、 title 、 untitle                     |
| snakecase 、 camelcase 、 kebabcase                    |
| swapcase                                               |
| substr                                                 |
| trunc                                                  |
| abbrev                                                 |
| randAlphaNum 、 randAlpha 、 randNumeric  、 randAscii |
| contains                                               |
| hasPrefix 、 hasSuffix                                 |
| repeat 、 nospace 、 initials                          |
| wrapWith                                               |
| quote 、 squote                                        |
| replace                                                |
| shuffle                                                |
| indent 、 nindent                                      |
| plural                                                 |

#### 4.3.2 print和println函数

将所有参数按照字符串进行输出，与print不同的是，println会在每个字符串后面添加一个空格，并且会在输出的末尾添加一个换行符。如果参数中包含非字符串类型，那么输出的时候会转成字符串类型。当相邻两个参数不是字符串时，会在它们中间添加一个空格。

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  type1: {{ print "this is" "test" "message" }} # this istestmessage
  type2: {{ println "this is" "test" "message" }} # type2: this is test message 注：还有一个空白行
  type3: {{ print "this is" 2 3 "message" }} # this is2 3message
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.3 printf函数

用于格式化输出字符串内容，并且支持使用占位符。占位符取决于传入参数的类型。

printf函数常用类型 - 整数

| 占位符 | 含义                               |
| ------ | ---------------------------------- |
| %b     | 二进制                             |
| %c     | 表示普通字符                       |
| %d     | 十进制                             |
| %o     | 八进制                             |
| %O     | 带0o前缀的八进制                   |
| %q     | 安全转义的单引号字符               |
| %x     | 16进制，使用小写字符a-f            |
| %X     | 16进制，使用大写字符A-F            |
| %U     | Unicode格式，U+1234;和“U+%04X”相同 |

printf函数常用类型 - 浮点数

| 占位符 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| %b     | 指数二次幂的无小数科学计数法，比如：-123456p-78              |
| %e     | 科学计数法，比如：-1.234456e+78                              |
| %E     | 科学计数法，比如：-1.234456E+78                              |
| %f     | 无指数的小数，比如：123.456                                  |
| %F     | 与%f同义                                                     |
| %g     | %e的大指数，否则是%f                                         |
| %G     | %E的大指数，否则是%F                                         |
| %x     | 十六进制计数法（和两个指数的十进制幂），比如：-0x1.23abcp+20 |
| %X     | 大写的十六进制计数法，比如：-0X1.23ABCP+20                   |

printf函数常用类型 - 字符串

| 占位符 | 含义                             |
| ------ | -------------------------------- |
| %s     |                                  |
| %q     | 安全转义的双引号弹幕             |
| %x     | 十六进制，小写，每个字节两个字符 |
| %X     | 十六进制，大写，每个字节两个字符 |

printf函数常用类型 - 布尔值

| 占位符 | 含义             |
| ------ | ---------------- |
| %t     | 输出指定的布尔值 |

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  type1: {{ printf "the bollean is %t" true }} # the bollean is true
  type2: {{ printf "the str is %s" "strtest" }} # the str is strtest
  type3: {{ printf "the num is %d" 18 }} # the num is 18
  type4: {{ printf "the float is %.2f" 3.123 }} # the float is 3.12
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.4 trim、trimAll、trimPrefix、trimSuffix函数

| 函数                       | 含义                                                    |
| -------------------------- | ------------------------------------------------------- |
| trim                       | 可以用来去除字符串两边的空格，示例： `trim " hello "`   |
| trimAll函数                | 用于移除字符串中指定的字符，示例：`trimAll "$" "$5.00"` |
| trimPrefix和trimSuffix函数 | 分别用于移除字符串中指定的前缀和后缀                    |

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ trim "Test" }} # Test
  data2: {{ trimAll "%" "%Test" }} # Test
  data3: {{ trimPrefix "-" "-hello" }} # hello
  data4: {{ trimSuffix "+" "hello+" }} # hello
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.5 lower、upper、title和untitle函数

| 函数    | 含义                                                  |
| ------- | ----------------------------------------------------- |
| lower   | 用于将所有字母转换成小写，示例1：`lower "HELLO"`      |
| upper   | 用于将所有字母转换成大写，示例2：`upper "hello"`      |
| title   | 用于将首字母转换成大写，示例3：`title "test"`         |
| untitle | 用于将大写的首字母转换成小写，示例4：`untitle "Test"` |

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ lower "HELLO" }} # hello
  data2: {{ upper "hello" }} # HELLO
  data3: {{ title "test" }} # Test
  data4: {{ untitle "Test" }} # test
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.6 snakecase、camelcase和kebabcase函数

| 函数      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| snakecase | 用于将驼峰写法转换为下划线命名写法，示例：`snakecase "UserName"` # 返回结果 user_name |
| camelcase | 用于将下划线命名写法转换为驼峰写法，示例：`camelcase "user_name"` # 返回结果 UserName |
| kebabcase | 用于将驼峰写法转换为中横线写法，示例：`kebabcase "UserName"` # 返回结果 user-name |

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ snakecase "UserName" }} # user_name
  data2: {{ camelcase "user_name" }} # UserName
  data3: {{ kebabcase "UserName" }} # user-name
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.7 swapcase函数

| 函数     | 含义                               |
| -------- | ---------------------------------- |
| swapcase | 基于内置的算法来切换字符串的大小写 |

- 算法规则如下：
  - 大写字母变成小写字母
  - 首字母变成小写字母
  - 空格后或开头的小写字母转换成大写字母
  - 其他小写字母转换成大写字母

示例：`swapcase "This Is A.Test"` # 返回结果：`tHIS iS a.tEST`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ swapcase "This Is A.Test" }} # tHIS iS a.tEST
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.8 substr函数

| 函数   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| substr | 用于切割字符串（指定切割起始位置），并且返回切割后的字符串。 |

该函数需要指定三个参数：

- start(int)：起始位置（含），索引位置从0开始
- end(int)：结束位置（不含），索引位置从0开始
- string(string)：需要切割的字符串

示例：`substr 3 5 "message"` # 返回结果`“sa”`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ substr 3 5 "message" }} # sa
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.9 trunc函数

| 函数  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| trunc | 用于阶段字符串。trunc可以使用正整数或负整数来分别表示从左向右或从右向左截取的个数 |

示例：`trunc 5 "Hello World"` # 返回结果：`Hello`

示例：`trunc -5 "Hello World"` # 返回结果：`World`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ trunc 5 "Hello World" }} # Hello
  data2: {{ trunc -5 "Hello World" }} # World
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.10 abbrev函数

| 函数   | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| abbrev | 作用是使用省略号（…）切割字符串，保留指定的长度，注意省略号的长度占保留长度的3个。 |

示例：`abbrev 5 "Hello World"` # 返回结果：`He...`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ abbrev 5 "Hello World" }} # He...
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.11 randAlphaNum、randAlpha、randNumeric和randAscii函数

用于生成加密的随机字符串，指定生成的字符串长度（生成几个长度）

| 函数         | 含义                                        |
| ------------ | ------------------------------------------- |
| randAlphaNum | 使用0-9a-zA-Z生成随机字符串                 |
| randAlpha    | 使用a-zA-Z生成随机字符串                    |
| randNumeric  | 使用0-9生成随机字符串                       |
| randAscii    | 使用所有的可使用的ASCII字符，生成随机字符串 |

注意：每个函数都需要传递一个参数用于指定生成的字符串长度。示例：`randNumeric 3`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ randAlphaNum 10 }}
  data2: {{ randAlpha 10 }}
  data3: {{ randNumeric 10 }}
  data4: {{ randAscii 10 }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.12 contains函数

用于测试一个字符串是否包含在另一个字符串里面，返回布尔值，true或false，若包含返回true，不包含返回false。

示例：`contains "llo" "Hello"` # 结果返回true

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ contains "llo" "Hello" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.13 hasPrefix和hasSuffix函数

这两个函数用于测试一个字符串是否是指定字符串的前缀或后缀，返回布尔值 true 或 false，包含返回true，不包含返回false。

示例：`hasPrefix "He" "Hello"` # 判断前缀，是前缀，返回true

示例：`hasSuffix "le" "Hello"` # 判断后缀，不是后缀，结果返回false

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ hasPrefix "He" "Hello" }}
  data2: {{ hasSuffix "le" "Hello" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.14 repeat、nospace和initials函数

| 函数     | 含义                                               |
| -------- | -------------------------------------------------- |
| repeat   | 用于将字符串重复输出指定的次数                     |
| nospace  | 用于去掉字符串中所有的空格                         |
| initials | 用于截取指定字符串的每个单词的首字母，并拼接在一起 |

示例：`repeat 3 "Hello"` # 结果返回 HelloHelloHello

示例：`nospace "T e s t"` # 结果返回 Test

示例：`initials "People Like Peace"` # 返回PLP

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ repeat 3 "Hello" }}
  data2: {{ nospace "T e s t" }}
  data3: {{ initials "People Like Peace" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.15 wrapWith函数

作用是在文档中在指定的列数添加内容，例如添加内容：`"\t"`

示例：`wrapWith 5 "\t" "HelloWorld"`，会在第五个索引的位置添加`“\t”`，所以结果为：`“Hello World”`'

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ wrapWith 5 "\t" "HelloWorld" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.16 quote和squote函数

该函数将字符串用双引号（quote）或者单引号（squote）括起来。

示例：`quote hello`

示例：`squote hello`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ hello | quote }}
  data2: {{ hello | squote }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.17 cat函数

用于将多个字符串合并成一个字符串，并使用空格分隔开

示例：`cat "Hello" "World"`，结果：`Hello World`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ cat "Hello" "World" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.18 replace函数

用于执行简单的字符串替换。该函数需要传递三个参数：待替换的字符串、将要替换的字符串、源字符串

第1个参数：待替换的字符串

第2个参数：将要替换的字符串

第3个参数：源字符串

示例：`"I Am Test" | replace " " "-"` # 返回结果：`I-Am-Test`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ "I Am Test" | replace " " "-" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.19 shuffle函数

用于对字符串中的字符进行重新排序，是基于他内部的一个算法

示例：`shuffle "Hello"` # 得到结果是不确定的，比如：`Hloel`或`loeHl`等等

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ shuffle "Hello" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.20 indent和nindent函数

用于以指定长度来缩进指定字符串的所在行。其中nindent函数可以在缩进时在字符串开头添加新行。

示例：`indent 4 "this is indent"`

示例：`nindent 4 "this is nindent"`

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: | # 定义多行字符串时的 
    {{ nindent 4 "this is nindent" }}
    {{ indent 4 "this is indent" }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.3.21 plural函数

判断字符串的长度，并且根据长度返回不同的值。

如：字符串的长度为1会返回plural函数的第一个参数，若不是1则返回第二个参数（包括0）

示例：`len "a" | plural "one" "many"` # 结果返回one

示例：`len "abc" | plural "one" "many "`  # 结果返回many

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ len "a" | plural "one" "many" }} # one
  data2: {{ len "abc" | plural "one" "many" }} # many
  data3: {{ len "" | plural "one" "many" }} # many
  data4: {{ len "abc" }} # 3
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.4 helm3的类型转换函数和正则表达式函数

#### 4.4.1 常用的helm3类型转换函数和正则表达式函数

- 类型转换函数

| 函数                           | 含义                                                       |
| ------------------------------ | ---------------------------------------------------------- |
| atoi                           | 将字符串转换为整型                                         |
| float64                        | 转换成float64类型                                          |
| int                            | 转换为int类型                                              |
| toString函数                   | 转换成字符串                                               |
| int64                          | 转换成int64类型                                            |
| toDecimal                      | 将unix八进制转换成int64                                    |
| toStrings                      | 将列表、切片或数组转换成字符串列表                         |
| toJson(mustToJson)             | 将列表、切片、数组、字典或对象转换成JSON                   |
| toPrettyJson(mustToPrettyJson) | 将列表、切片、数组、字典或对象转换成格式JSON               |
| toRawJson(mustToRawJson)       | 将列表、切片、数组、字典或对象转换成JSON（HTML字符不转义） |

- 正则表达式函数

| 函数                                                 | 含义                                                         |
| ---------------------------------------------------- | ------------------------------------------------------------ |
| regexFind 和 mustRegexFind                           | 根据正则匹配查找匹配的内容，都是用于获取字符串中第一个匹配正则表达式的结果（从左至右） |
| regexFindAll 和 mustRegexFindAll                     | 用于获取字符串中匹配正则表达式的所有子字符串内容，<br />并且在该函数的最后指定一个整型来表示返回多少个正则匹配的字符串。-1表示返回所有正则匹配的结果。 |
| regexMatch 和 mustRegexMatch                         | 用于根据指定的正则来匹配字符串，如果匹配成功则返回true；<br />如果表达式有问题，regexMatch会直接抛出错误，mustRegexMatch会向模板引擎返回错误。 |
| regexReplaceAll 和 mustRegexReplaceAll               | 用指定的替换字符串来替换正则表达式匹配到的字符串<br />在替换字符串里面，`$`符号代表扩展符号，`$1`代表正则表达式的第一个分组 |
| regexReplaceAllLiteral 和 mustRegexReplaceAllLiteral | 将通过正则匹配到的内容，替换成其他内容；函数会把 `$` 也当做字符串直接替换。 |
| regexSplit 和 mustRegexSplit                         | 作用都是指定一个分隔符（以正则表达式匹配的内容为分隔符），将字符串进行切割，并返回切割后的字符串切片。<br />在函数的最后需要指定一个整数，来确定要返回的切片数量，-1代表返回所有的切片。 |

#### 4.4.2 atoi、float64、int、toString函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ "16" | kindOf }} # string
  data2: {{ 16 | kindOf }} # int
  data3: {{ atoi "16" | kindOf }} # int
  data4: {{ float64 "16.0" | kindOf }} # float64
  data5: {{ int "16" | kindOf }} # int
  data6: {{ toString "16" | kindOf }} # string
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.4.3 regexMatch 和 mustRegexMatch 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  # 注意这里的 \\\\ 会被转义为 \\
  data1: {{ regexMatch "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$" "test@xxx.com" }} # true
  data2: {{ mustRegexMatch "^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,}$" "test@xxx.com" }} # true
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.4.4 regexFindAll 和 mustRegexFindAll 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ regexFindAll "[2,4,6,8]" "123456789" 3 | quote }} # "[2 4 6]"
  data2: {{ regexFindAll "[2,4,6,8]" "123456789" -1 | quote }} # "[2 4 6 8]"
  data3: {{ mustRegexFindAll "[2,4,6,8]" "123456789" 3 | quote }} # "[2 4 6]"
  data4: {{ mustRegexFindAll "[2,4,6,8]" "123456789" -1 | quote }} # "[2 4 6 8]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.4.5 regexFind 和 mustRegexFind 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ regexFind "[a-zA-Z][1-9]" "abcd1234c1" }} # d1
  data2: {{ mustRegexFind "[a-zA-Z][1-9]" "abcd1234c1" }} # d1
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.4.6 regexReplaceAll 和 mustRegexReplaceAll 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ regexReplaceAll "ab" "-ab-ab-axxb-" "W" }} # -W-W-axxb-
  data2: {{ regexReplaceAll "a(x*)b" "-ab-axxb-" "W" }} # -W-W-
  data3: {{ regexReplaceAll "a(x*)b" "-axb-axxb-" "W" }} # -W-W-
  # \$s代表正则表达式的第一个分组（第一个括号里的(x*)），\$1的值会保留，其他匹配到正则的都会被替换为W
  data4: {{ regexReplaceAll "a(x*)b" "-ab-axxb-" "\${1}W" }} # -W-xxW-
  data5: {{ mustRegexReplaceAll "ab" "-ab-ab-axxb-" "W" }} # -W-W-axxb-
  data6: {{ mustRegexReplaceAll "a(x*)b" "-ab-axxb-" "W" }} # -W-W-
  data7: {{ mustRegexReplaceAll "a(x*)b" "-axb-axxb-" "W" }} # -W-W-
  data8: {{ mustRegexReplaceAll "a(x*)b" "-ab-axxb-" "\${1}W" }} # -W-xxW-
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.4.7 regexReplaceAllLiteral 和 mustRegexReplaceAllLiteral 函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ regexReplaceAllLiteral "ab" "-ab-ab-axxb-" "W" }} # -W-W-axxb-
  data2: {{ regexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "W" }} # -W-W-
  data3: {{ regexReplaceAllLiteral "a(x*)b" "-axb-axxb-" "W" }} # -W-W-
  data4: {{ regexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "\${1}W" }} # -${1}W-${1}W-
  data5: {{ mustRegexReplaceAllLiteral "ab" "-ab-ab-axxb-" "W" }} # -W-W-axxb-
  data6: {{ mustRegexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "W" }} # -W-W-
  data7: {{ mustRegexReplaceAllLiteral "a(x*)b" "-axb-axxb-" "W" }} # -W-W-
  data8: {{ mustRegexReplaceAllLiteral "a(x*)b" "-ab-axxb-" "\${1}W" }} # -${1}W-${1}W-
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.4.8 regexSplit 和 mustRegexSplit 函数

示例：`regexSplit "z+" "pizza" -1` 正则表达式含义：可以匹配1-多个z，匹配到正则的内容。

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ regexSplit "z+" "pizza" -1 | quote }} # "[pi a]"
  data2: {{ mustRegexSplit "z+" "pizza" -1 | quote  }} # "[pi a]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.5 helm3的加密函数和编码解码函数

#### 4.5.1 常用的helm3加密函数和编码解码函数

- 加密函数

| 函数       | 含义                                                         |
| ---------- | ------------------------------------------------------------ |
| sha1sum    | 用于计算字符串的SHA1值进行加密                               |
| sha256sum  | 用于计算字符串的SHA256值进行加密                             |
| adler32sum | 用于计算字符串的Adler-32校验和进行加密                       |
| htpasswd   | 可以根据传入的username和password生成一个密码的bcrypt哈希值，<br />可以用于HTTP Server的基础认证 |
| encryptAES | 使用AES-256 CBC加密文本并返回一个Base64编码字符串            |
| decryptAES | 接收一个AES-256 CBC加密的字符串并返回解密文本                |

- 编码解码函数

| 函数             | 含义              |
| ---------------- | ----------------- |
| b64enc 和 b64dec | 编码或解码 Base64 |
| b32enc 和 b32dec | 编码或解码 Base32 |

#### 4.5.2 sha1sum、sha256sum、adler32sum和htpasswd函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ sha1sum "hello world" }} # 多次执行结果一致
  data2: {{ sha256sum "hello world" }} # 多次执行结果一致
  data3: {{ adler32sum "hello world" }} # 多次执行结果一致
  data4: {{ htpasswd "user1" "123456" }} # 结果每次都有变化
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.5.3 encryptAES 加密函数 和 decryptAES 解密函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ encryptAES "testkey" "hello" }} # 多次执行得到密文不一致
  data2: {{ decryptAES "testkey" "jAnXVjPAGbegqxzexUv0P5H3h2YRRnMzPS4VCRQa8lA=" }} # hello
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.5.4 b64enc编码函数和b64dec解码函数

<span style="color:red;font-weight:bold;">编写K8S的secret文件时会用到</span>

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ "test" | b64enc }} # dGVzdA==
  data2: {{ "dGVzdA==" | b64dec }} # test
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.6 helm3的日期函数

#### 4.6.1 常用的helm3的日期函数

| 函数                         | 含义                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| now                          | 用于返回当前日期和时间，通常与其他日期函数共同使用           |
| date                         | 用于将日期信息进行格式化。date函数后面需要指明日期的格式，这个格式内容必须使用“2006-01-02”或“02/01/2006”来标明，否则会出错。<br />比如：`now | date "2006-01-02"` 或 `now | date "02/01/2006"`<br /><span style="color:red;font-weight:bold;">注意：格式内容必须是这两个示例的内容，内容换成其他日期都不行。</span> |
| dateInZone                   | 用法与date函数基本一致，只不过dateInZone函数可以指定时区返回时间，如：指定UTC时区返回时间。示例：`dateInZone "2006-01-02" (now) "UTC"` # 指定UTC时区返回时间 |
| duration                     | duration函数可以将给定的秒数转换为golang中的time.duration类型，例如指定95秒可以返回1m35s，秒数必须需要使用双引号，否则会返回0s。示例：`duration "95"` # 结果：1m35s |
| durationRound                | durationRound函数用于将给定的日期进行取整，保留最大的单位。<br />示例：`durationRound "2h10m5s"` # 结果：2h |
| unixEpoch                    | 用于返回给定时间的时间戳格式。示例：`now | unixEpoch`        |
| dateModify 和 mustDateModify | 这两个函数用于将一个给定的日期修改一定的时间，并返回修改后的时间。区别是：如果修改格式错误，dateModify会返回日期未定义，而mustDateModify会返回错误。<br />示例：`now | date_modify "-2h"` # 将当前时间减去2h再返回 |
| toDate 和 mustToDate         | 这两个函数都是用于将指定的字符串转换成日期，第一个参数需要指明要转成的日期格式，第二个参数需要传递要转换的字符串。<br />区别是：如果字符串无法转换，toDate函数就会返回0.mustToDate函数无法转换时会抛出错误。<br />示例：`toDate "2006-01-02" "2017-12-32"` |

#### 4.6.2 now、date、dateInZone、duration、durationRound函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ now }} # 2025-07-03 13:11:23.033771762 +0800 CST m=+0.050627764
  data2: {{ now | date "2006-01-02" }} # 2025-07-03
  data3: {{ dateInZone "2006-01-02" (now) "UTC" }} # 2025-07-03
  data4: {{ duration "95" }} # 1m35s
  data5: {{durationRound "2h10m5s" }} # 2h
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.6.3 unixEpoch

unixEpoch、dateModify、mustDateModify、toDate、mustToDate函数

```bash
# 编写一个自己需要的模板文件
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ now | unixEpoch }} # 1751520415
  data2: {{ now | date_modify "-2h"}} # 2025-07-03 11:26:55.270419717 +0800 CST m=-7199.958596527
  data3: {{ now | mustDateModify "-2h" }} # 2025-07-03 11:26:55.270436253 +0800 CST m=-7199.958580033
  data4: {{ toDate "2006-01-02" "2017-12-31" }} # 2017-12-31 00:00:00 +0800 CST
  data5: {{ mustToDate "2006-01-02" "2017-12-31" }} # 2017-12-31 00:00:00 +0800 CST
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.7 helm3的字典函数

#### 4.7.1 常用的helm3的字典函数

| 函数                               | 含义                                                         |
| ---------------------------------- | ------------------------------------------------------------ |
| dict                               | 声明一个字典，用于存储key/value键值对，其中字典的key必须是字符串，value可以是任何类型。 |
| get                                | 函数来获取定义字典myDict的值                                 |
| set                                | 用于向已有的字典中添加新的键值对，也可修改原来键值对的值     |
| unset                              | 用于删除字典中指定的key                                      |
| keys                               | keys函数用于获取一个或多个字典中所有的key并返回一个列表。由于字典是无序的，所以每次返回的列表中key的顺序也是会变化的。在指定多个字典并且字典中存在相同key的时候这些key都会被保存在列表中。<br />列表中如果包含多个相同的key，并且是无序的。可以使用sortAlpha函数对列表进行排序，再使用uniq函数去重。 |
| hasKey                             | 用于判断字典中是否包含指定的key，如果包含则返回true，否则返回false； |
| pluck                              | 可以根据一个key在多个字典中时获得所有匹配的value，并返回一个value组成的列表。<br />如果key值在两个字典中都不存在，则会返回一个空列表。 |
| merge、mustMerge                   | 两个函数都是用于合并两个或多个字典，由源字典向目标字典合并，如果目标字典中已经存在相同的key值，则忽略源字典中对应的键值对，以目标字典为主。如果源字典中的key没有包含在目标字典中，那么将对应的键值对合并到目标字典中。使用mustMerge合并时，如果合并不成功会抛出错误。<br />示例：<span style="color:red;font-weight:bold;">`merge $destDict $sourceDict1 $sourceDict2`</span>，$destDict是目标字典，把后面的所有字典都合并到第一个字典中。 |
| mergeOverwrite、mustMergeOverwrite | 这两个函数也是用来合并字典，但与merge函数不同的是，如果目标字典中存在与源字典中相同的key，那么目标字典中的key会被覆盖，mustMergeOverwrite会返回错误，以防出现不成功的合并。 |
| values                             | values函数用于获取一个字典中所有的value值并返回一个列表，由于字典是无序的，所以返回的list的内容页是无序的，如果需要排序和去重，可以使用sortAlpha函数对lie进行排序，再使用uniq函数去重。 |
| pick                               | 用于根据指定的字典和key值获取value，并将key和value组成一个新的字典返回。 |
| omit                               | 与pick函数正好相反，该函数会将指定的key值忽略，获取的是未被定义的key和value（也就是取反），并返回一个新的字典。 |
| deepCopy、mustDeepCopy             | 这两个函数都是用于深度拷贝一个字典并返回一个字典（也就是复制一个字典）；deepCopy有问题时会出错，而mustDeepCopy出错时，会返回一个错误给模板系统。 |

#### 4.7.2 dict字典函数、get函数、set函数、unset函数

- dict字典函数

dict字典类型函数用于存储key/value键值对。其中字典的key必须是字符串，value可以是任何类型，包括dict或list（列表会在后面讲解）。

dict函数用于声明一个字典，并且可以将键值对列表传入初始化的字典中：

示例：`$myDict:=dict "name1" "value1" "name2" "value2" "name3" "value3"`

打印这个变量，可以获取如下结果：`map[name1:value1 name2:value2 name3:value3]`

- get函数

get函数用于从一个映射（变量名）中根据key值获取对应的value；

示例：`get $myDict "name1"`

如果该key不存在，或者value为空，则会返回“”，不会抛出异常。

- set函数

set函数用于向已有的字典中添加新的键值对；

示例：`sset $myDict "name4" "value4"`

set函数执行完成后会返回一个字典，所以返回结果如下：

`map[name1:value1 name2:value2`

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict := dict "name1" "value1" "name2" "value2" "name3" "value3" }} 
  data1: {{ \$myDict }} # map[name1:value1 name2:value2 name3:value3]
  data2: {{ get \$myDict "name1"}} # value1
  data3: {{ set \$myDict "name4" "value4" }} # map[name1:value1 name2:value2 name3:value3 name4:value4]
  data4: {{ get \$myDict "name4" }} # value4
  data5: {{ unset \$myDict "name4" }} # map[name1:value1 name2:value2 name3:value3]
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.3 keys函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" }} 
  {{- \$myDict2 := dict "name1" "value1" "name3" "value3" }} 
  {{- \$myDict3 := dict "name1" "value1" "name4" "value4" }} 
  data1: {{ keys \$myDict1 \$myDict2 \$myDict3 | quote }} #  "[name2 name1 name1 name3 name1 name4]" 
  data2: {{ keys \$myDict1 \$myDict2 \$myDict3 | sortAlpha | uniq | quote }} # "[name1 name2 name3 name4]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.4 hasKey函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" }} 
  {{- \$myDict2 := dict "name1" "value1" "name3" "value3" }} 
  data1: {{ hasKey \$myDict1 "name1" }} # true
  data2: {{ hasKey \$myDict2 "name4" }} # false
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.5 pluck函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" }} 
  {{- \$myDict2 := dict "name1" "value1" "name3" "value3" }} 
  data1: {{ pluck "name1" \$myDict1 \$myDict2 | quote }} # "[value1 value1]"
  data2: {{ pluck "name2" \$myDict1 \$myDict2 | quote }} # "[value2]"
  data3: {{ pluck "name4" \$myDict1 \$myDict2 | quote }} # "[]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.6 merge函数和mustMerge函数的使用

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" }} 
  {{- \$myDict2 := dict "name1" "value1" "name3" "value3" }} 
  {{- \$myDict3 := dict "name1" "value4" "name5" "value5" }} 
  data1: {{ merge \$myDict1 \$myDict2 \$myDict3 }} # map[name1:value1 name2:value2 name3:value3 name5:value5] 
  data2: {{ mustMerge \$myDict1 \$myDict2 \$myDict3 }} # map[name1:value1 name2:value2 name3:value3 name5:value5]
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.7 mergeOverwrite函数和mustMergeOverwrite函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" }} 
  {{- \$myDict2 := dict "name1" "value1" "name3" "value3" }} 
  {{- \$myDict3 := dict "name1" "value4" "name5" "value5" }} 
  data1: {{ mergeOverwrite \$myDict1 \$myDict2 \$myDict3 }} # map[name1:value4 name2:value2 name3:value3 name5:value5] 
  data2: {{ mustMergeOverwrite \$myDict1 \$myDict2 \$myDict3 }} # map[name1:value4 name2:value2 name3:value3 name5:value5] 
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.8 values函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" "name3" "value3" }} 
  data1: {{ values \$myDict1 | quote }} # "[value1 value2 value3]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.9 pick函数和omit函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" "name3" "value3" }} 
  data1: {{ pick \$myDict1 "name1" "name2" }} # map[name1:value1 name2:value2]
  data2: {{ omit \$myDict1 "name1" "name2" }} # map[name3:value3]
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.7.10 deepCopy函数和mustDeepCopy函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myDict1 := dict "name1" "value1" "name2" "value2" "name3" "value3" }} 
  data1: {{ \$myDict1 | deepCopy }} # map[name1:value1 name2:value2 name3:value3]
  data2: {{ \$myDict1 | mustDeepCopy }} # map[name1:value1 name2:value2 name3:value3]
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.8 helm3的列表函数

#### 4.8.1 常用的helm3的列表函数

| 函数      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| list      | 用于生成一个列表，传入的参数将会作为列表中的值。<br />示例：`$myList := list 1 2 3 "one" "two" "three"` |
| first     | 用于获取列表的第一项，示例：`first $myList`                  |
| rest      | 用于获取列表中除第一项以外的所有内容，示例：`rest $myList`   |
| last      | 用于获取列表的最后一项，示例：`last $myList`                 |
| initial   | 获取到列表中除最后一项以外的所有内容，与rest正好相反，示例： `initial $myList` |
| append    | 用于在已有的列表中追加一项，并返回一个新的列表。原列表内容保持不变。<br />格式：`$newList = append $列表变量 要追加的内容` |
| prepend   | 用于在列表的最前面加入一个新值，并返回一个新的列表，原列表内容不变。<br />格式：`$newList = prepend $列表变量 最前面加的值` |
| concat    | 用于将任意数量的列表合并成一个新的列表，原列表内容保持不变。<br />格式：`concat $源列表名 新列表1 新列表2 ...` 示例：`concat $myList (list 100 101 102) (list a b c)` |
| reverse   | 用于翻转一个列表，并返回一个新的列表。示例：`reverse $myList` |
| uniq      | 用于去除一个列表中的重复项，并返回一个新的列表。示例：`list 1 1 2 2 3 3                                                                                                                                                                                                                                                                                                | uniq` |
| without   | 用于过滤掉列表中的指定值（即：不要某某个值或多个值），并返回包含剩下值的列表。<br />示例：`without (list 1 2 3 4) 3`（过滤掉3）。<br />也可过滤掉多个值，示例：`without (list 1 2 3 4) 2 3 `（过滤掉2 3） |
| has       | 用于判断一个值是否包含在列表中，如果包含返回true，否则返回false。<br />示例：`has "hello" (list 1 2 3 4)                                                                                                                                                                                                                                                                   | quote` |
| compact   | 用来删除一个列表中的<span style="color:red;font-weight:bold;">空值</span>，并返回一个新的列表。<br />示例：`compact (list 1 2 3 "")                                                                                                                                                                                                                                   | quote` |
| slice     | 用于对列表进行切片，命令格式为`slice list [n] [m]`，相当于 `list[n:m]`<br />`$myList := list 1 2 3 4 5 `<br />`slice $myList` 返回 `[1 2 3 4 5]`，等同于 `myList[:]`，没有设置步长，返回所有<br />`slice $myList 3`返回`[4 5]` 等同于`myList[3:]`，从索引为3的位置进行切片。<br />`slice $myList 1 3`返回`[2 3]`等同于`myList[1:3]`，从索引为1的位置进行切片，切到索引3.<br />`slice $myList 0 3`返回`[1 2 3]`等同于`myList[:3]`，从索引为0的位置进行切片，切到索引3. |
| until     | 用于构建一个指定整数范围内的列表，示例：`until 5`，从0开始，不包含5。 |
| untilStep | 与until作用类似，不过可以定义整数的开始和步长。<br />示例：`untilStep 3 9 2`，输出3-9之间的数字，且步长值为2。 |
| seq       | 与linux中的seq命令类似，用于生成指定范围内的整数。最多可以传递三个参数：<br />单个参数（结束位置）-会生成所有从1到包含end的整数。<br />多个参数（开始，结束）-会生成所有从1到包含end的整数。<br />多个参数（开始，步长，结束）-会生成所有包含start和end按step递增或递减的整数。<br />示例：<br />seq 5 => 1 2 3 4 5<br />seq -3 => 1 0 -1 -2 -3<br />seq 0 2 => 0 1 2<br />seq 2 -2 => 2 1 0 -1 -2<br />seq 0 2 10 => 0 2 4 6 8 10<br />seq 0 -2 -5 =>0 -2 -4 |

:::info

什么是空类型？主要有以下几种：

- 整型：0

- 字符串：“”

- 列表：[]

- 字典：{}

- 布尔：false

- 以及所有的nil（或者null）

:::

#### 4.8.2 list、first、rest、last、initial函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myList := list 1 2 3 "one" "two" "three" }} 
  data1: {{ \$myList | quote }}  # "[1 2 3 one two three]"
  data2: {{ first \$myList | quote }} # "1"
  data3: {{ rest \$myList | quote }} # "[2 3 one two three]"
  data4: {{ last \$myList | quote }} # "three"
  data5: {{ initial \$myList | quote }} # "[1 2 3 one two]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.8.3 append、prepend、concat、reverse、uniq函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myList := list 1 2 3 "one" "two" "three" }} 
  data1: {{ append \$myList "append_test" | quote }} # "[1 2 3 one two three append_test]""
  data2: {{ prepend \$myList "prepend_test" | quote }} # "[prepend_test 1 2 3 one two three]"
  data3: {{ concat \$myList (list 100 101 102) (list 200 201) | quote }} # "[1 2 3 one two three 100 101 102 200 201]" 
  data4: {{ reverse \$myList | quote }} # "[three two one 3 2 1]"
  data5: {{ list 1 1 2 2 3 3 | uniq | quote }} # "[1 2 3]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.8.4 without、has、compact函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ without (list 1 2 3 4) 3 | quote }} # "[1 2 4]"
  data2: {{ without (list 1 2 3 4) 2 3 | quote }} # "[1 4]"
  data3: {{ has "hello" (list 1 2 3 4) | quote }} # "false"
  data4: {{ has 2 (list 1 2 3 4) | quote }} # "true"
  data5: {{ compact (list 1 2 3 "") | quote }} # "[1 2 3]"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.8.5 slice、until、untilStep、seq函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  {{- \$myList := list 1 2 3 4 5 }}
  data1: {{ slice \$myList | quote }} # "[1 2 3 4 5]""
  data2: {{ slice \$myList 3| quote }} # "[4 5]"
  data3: {{ slice \$myList 1 3 | quote }} # "[2 3]"
  data4: {{ slice \$myList 0 3 | quote }} # "[1 2 3]"
  data5: {{ until 5 | quote }} # "[0 1 2 3 4]"
  data6: {{ untilStep 3 9 2 | quote }} # "[3 5 7]"
  data7: {{ seq 5 | quote }} # "1 2 3 4 5"
  data8: {{ seq 0 2 | quote }} # "0 1 2"
  data9: {{ seq 0 2 10 | quote }} # "0 2 4 6 8 10"
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.9 helm3的数学计算函数

#### 4.9.1 常用helm3的数学计算函数

| 函数  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| add   | 加法，可以接受两个或多个参数。示例：`add 1 2 3` # 计算加，返回6 |
| sub   | 减法，可以接受两个。示例：`sub 3 2` # 计算减，返回1          |
| mul   | 乘法，可以接受两个。示例：`mul 3 2` # 计算除，返回6          |
| div   | 除法，可以接受两个。示例：`div 6 3` # 计算除，返回2          |
| mod   | 取模，求余数；可以接受两个。示例：`mod 9 2` # 计算求余，返回1 |
| add1  | 用于给参数加1，只能接受一个参数。示例：`add1 3` # 给参数3加1，结果是4 |
| max   | 最大值，示例：`max 1 2 3`                                    |
| min   | 最小值，示例：`min 1 2 3`                                    |
| round | 用于计算输入值四舍五入后的值，需传入两个参数，最后一个参数代表保留的小数位。示例：`round 3.1415926 3` |
| len   | 用于计算参数的长度。示例：`len "abcde"`                      |
| floor | 用于返回小于等于输入值的最大浮点整数。示例：`floor 123.9999` # 返回 123 |
| ceil  | 用于返回大于等于输入值的最小浮点整数，返回的值一定要大于或等于输入的值。示例：`ceil 123.9999` # 返回 124 |

#### 4.9.2 add、sub、mul、div、mod、add1函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ max 1 2 3 | quote }}
  data2: {{ min 1 2 3 | quote }}
  data3: {{ round 3.1415926 3 | quote }}
  data4: {{ len "abcde" | quote }}
  data5: {{ floor 123.9999 | quote}}
  data6: {{ ceil 123.9999 | quote }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

### 4.10 helm3的网络函数、文件路径函数、类型检查函数

#### 4.10.1 常用helm3的网络函数、文件路径函数、类型检查函数

- getHostByName 网络函数

  - 用于接收一个域名并返回该域名的解析后的IP地址，示例：`getHostByName "www.baidu.com"`

- 文件路径函数 base函数、dir函数、ext函数、isAbs函数

  - base函数：用于返回指定路径的最后一级目录
  - dir函数：用于返回指定路径的上一级路径（也就是去掉最后一级路径）
  - ext函数：用于返回文件的拓展名
  - isAbs函数：用于判断文件路径是否是绝对路径，是绝对路径则返回true，否则返回false

- 类型检查和对比函数 kindOf函数、kindIs函数、deepEqual函数

  - kindOf函数：用于返回对象的类型

    - **`string`** - 字符串类型

      ```
      {{ kindOf "hello" }} → string
      ```

    - **`bool`** - 布尔类型
      ```
      {{ kindOf true }} → bool
      ```

    - **`int64`** - 整型（64 位）
      ```
      {{ kindOf 42 }} → int64
      ```

    - **`float64`** - 浮点型（64 位）
      ```
      {{ kindOf 3.14 }} → float64
      ```

    - **`slice`** - 数组/切片类型
      ```
      {{ kindOf (list 1 2 3) }} → slice
      ```

    - **`map`** - 字典/键值对类型
      ```
      {{ kindOf (dict "key" "value") }} → map
      ```

    - **`invalid`** - 无效类型（nil 或未定义值）
      ```
      {{ kindOf .UndefinedValue }} → invalid
      ```

  - kindIs函数：用于检测某个对象是否是指定的类型，返回布尔值，第一个参数需要指定类型，第二个参数需要指定检查的数据对象

  - deepEqual函数：用于判断两个对象的值是否完全一致，返回布尔值

#### 4.10.2 getHostByName函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ getHostByName "www.baidu.com" | quote }}
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.10.3 文件路径函数base函数、dir函数、ext函数、isAbs函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ base "/tmp/a/a.txt" }} # a.txt
  data2: {{ dir "/tmp/a/a.txt" }} # /tmp/a
  data3: {{ ext "a.txt" }} # .txt
  data4: {{ isAbs "/tmp/a" }} # true
  data5: {{ isAbs "tmp/a" }} # false
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```

#### 4.10.4 类型检查和对比函数 kindOf函数、kindIs函数和deepEqual函数

```bash
# 编写一个自己需要的模板文件
# 注意，-必须紧跟{{后面，中间不允许有空格
$ tee ~/mychart/templates/configmap.yaml << EOF
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-configmap
  namespace: {{ .Release.Namespace }}
data:
  data1: {{ kindOf (list 1 2 3) }} # slice
  data2: {{ kindIs "string" "hi" }} # true
  data3: {{ deepEqual (list 1 2 3) (list 1 2 3) }} # true
  data4: {{ deepEqual (list 1 2 3) (list 2 3 4) }} # false
  data5: {{ kindOf "hello world" }} # string
EOF

# 配置变量
$ tee ~/mychart/values.yaml << EOF
EOF

# 不真正执行，只是试运行看是否能运行
$ helm install myconfigmap ~/mychart --debug --dry-run
```









